---
/**
 * SMSMockup Component
 *
 * Fixed: Added CSS masking to prevent inner content from bleeding
 * outside the rounded corners of the iPhone frame.
 */

interface Message {
  type: 'incoming' | 'outgoing'
  content?: 'text' | 'image'
  text?: string
  imageSrc?: string
  imageAlt?: string
  timestamp?: string
}

interface Props {
  messages: Message[]
  contactName?: string
  className?: string
  autoplay?: boolean
}

const { messages, contactName = 'Return Signals', className = '', autoplay = false } = Astro.props

const lastOutgoingIndex = (() => {
  let idx = -1
  messages.forEach((m, i) => {
    if (m.type === 'outgoing') idx = i
  })
  return idx
})()
---

<div
  class={`sms-mockup ${autoplay ? 'sms-autoplay' : ''} mx-auto inline-flex flex-col items-center ${className}`}
  role="img"
  aria-label={`SMS conversation with ${contactName}`}
  style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, 'Apple Color Emoji', 'Segoe UI Emoji'"
  data-last-outgoing={lastOutgoingIndex}
  data-autoplay={autoplay}
>
  <!--
    FIX: Added 'transform-gpu' and 'mask-image' style
    This forces the browser to clip the inner absolute children (messages) to the border radius.
    Width calculated from aspect-ratio (390/676) + max-height (500px): 500 * 390/676 ≈ 288px
  -->
  <div
    class="sms-frame relative rounded-[28px] border-[6px] border-black bg-white shadow-2xl overflow-hidden flex flex-col transform-gpu w-[264px] sm:w-[288px]"
    style="aspect-ratio: 390/676; -webkit-mask-image: -webkit-radial-gradient(white, black);"
  >
    <!-- Dynamic Island -->
    <div
      class="absolute top-1 left-1/2 -translate-x-1/2 h-5 w-24 bg-black rounded-full z-20"
      aria-hidden="true"
    >
    </div>

    <!-- Status Bar -->
    <div
      class="sms-status-bar absolute top-0 left-0 right-0 z-10 flex items-center justify-between px-4 pt-2 pb-1 text-[#111827]"
    >
      <span class="text-[10px] font-semibold sms-time-display">9:41</span>
      <div class="flex items-center">
        <img src="/icons/iphone-mock/signal.svg" alt="" class="w-3 h-2 mr-1" />
        <img src="/icons/iphone-mock/wifi.svg" alt="" class="w-3 h-2.5" />
        <img src="/icons/iphone-mock/battery.svg" alt="" class="w-5 h-3" />
      </div>
    </div>

    <!-- Header overlay -->
    <div class="sms-header absolute left-0 right-0 z-10" style="top: 28px;">
      <div class="relative py-1.5">
        <div class="w-full flex items-start justify-between px-3">
          <div
            class="bg-[#FAFAFA]/90 backdrop-blur-md rounded-full flex items-center gap-1 text-[#007AFF] px-2 py-1 border border-white"
          >
            <img src="/icons/iphone-mock/chevron-left.svg" alt="" class="w-4 h-4" />
            <span
              class="text-[11px] font-medium bg-black text-white px-2 py-0.5 rounded-full sms-unread-count"
              >251</span
            >
          </div>
          <div
            class="bg-[#FAFAFA]/90 backdrop-blur-md rounded-full p-1.5 text-[#007AFF] border border-white"
          >
            <img src="/icons/iphone-mock/video-camera.svg" alt="" class="w-5 h-5" />
          </div>
        </div>
        <div class="absolute left-1/2 top-0 -translate-x-1/2 flex flex-col items-center gap-1 mt-2">
          <div class="h-7 w-7 rounded-full bg-[#6B7280] flex items-center justify-center p-1.5">
            <img src="/images/logo/logo-white.svg" alt="Return Signals" class="w-full h-full" />
          </div>
          <div
            class="bg-[#FAFAFA]/90 backdrop-blur-md rounded-full px-3 py-1 flex items-center gap-1 border border-white"
          >
            <span class="text-[13px] font-semibold text-black">Brand</span>
            <img src="/icons/iphone-mock/chevron-right.svg" alt="" class="w-1 h-2" />
          </div>
        </div>
      </div>
    </div>

    <!-- Top fade -->
    <div
      class="absolute top-0 left-0 right-0 pointer-events-none"
      style="height: 110px; z-index: 5; background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.4) 50%, rgba(255, 255, 255, 0) 100%);"
    >
    </div>

    <!-- Messages Container -->
    <div
      class="sms-messages absolute inset-0 overflow-y-auto px-3 space-y-2 bg-[#ECEDEF]"
      style="padding-top: 110px; padding-bottom: 55px;"
    >
      {
        messages.map((msg, i) => {
          const isOutgoing = msg.type === 'outgoing'
          const isImage = msg.content === 'image'
          return (
            <Fragment>
              {msg.timestamp && (
                <div class="sms-time" data-message-index={i}>
                  <span class="sms-time-pill">{msg.timestamp}</span>
                </div>
              )}
              <div
                class={`sms-bubble ${isOutgoing ? 'justify-end' : 'justify-start'}`}
                data-message-index={i}
              >
                {isImage ? (
                  <div
                    class={`image-bubble ${isOutgoing ? 'image-bubble-outgoing' : 'image-bubble-incoming'}`}
                  >
                    <img
                      src={msg.imageSrc}
                      alt={msg.imageAlt || 'Uploaded image'}
                      loading="lazy"
                      class="image-bubble-img"
                    />
                  </div>
                ) : (
                  <div class={isOutgoing ? 'bubble bubble-outgoing' : 'bubble bubble-incoming'}>
                    <p class="bubble-text">{msg.text}</p>
                  </div>
                )}
              </div>
              {i === lastOutgoingIndex && (
                <div class="sms-receipt" data-role="delivered">
                  Delivered
                </div>
              )}
            </Fragment>
          )
        })
      }
    </div>

    <!-- Bottom Input Bar -->
    <div
      class="sms-input-bar absolute bottom-0 left-0 right-0 z-10 flex items-center gap-2 px-2 py-2"
    >
      <button
        class="bg-[#FAFAFA]/90 backdrop-blur-md rounded-2xl w-7 h-7 flex items-center justify-center border border-white"
        aria-label="Add attachment"
      >
        <span class="text-black text-lg font-light" style="line-height: 1; margin-top: -1px;"
          >+</span
        >
      </button>
      <div
        class="flex-1 bg-[#FAFAFA] backdrop-blur-md rounded-full px-3 py-1 flex items-center justify-between border border-white"
      >
        <span class="text-[15px] text-[#8E8E93]">iMessage</span>
        <button class="text-[#9CA3AF]" aria-label="Voice message">
          <img
            src="/icons/iphone-mock/microphone.svg"
            alt=""
            class="w-4 h-4 opacity-60"
            style="filter: grayscale(0.3);"
          />
        </button>
      </div>
    </div>
  </div>

  <!-- Interaction hints -->
  <div class="mt-3 flex items-center justify-center gap-3 text-xs text-caption">
    <div class="flex items-center gap-1">
      <img src="/icons/scroll-vertical.svg" alt="" class="w-3 h-3 opacity-60" />
      <span>Scrollable</span>
    </div>
    <div class="text-tertiary">•</div>
    <div
      class="sms-replay-hint flex items-center gap-1 cursor-pointer hover:text-secondary transition-colors"
      role="button"
      tabindex="0"
    >
      <img src="/icons/replay.svg" alt="" class="w-2.5 h-2.5 opacity-60" />
      <span>Click to replay</span>
    </div>
  </div>
</div>

<style>
  /* Same styles as before, nothing needs to change here */
  .sms-header {
    background: transparent;
  }
  .sms-input-bar {
    background: transparent;
  }
  .sms-bubble {
    display: none;
  }
  .sms-bubble.visible {
    display: flex;
  }
  @media (prefers-reduced-motion: reduce) {
    .sms-bubble {
      display: flex !important;
    }
  }
  .sms-time {
    display: none;
    justify-content: center;
    margin: 8px 0;
  }
  .sms-time.visible {
    display: flex;
  }
  .sms-time-pill {
    color: #8e8e93;
    font-size: 12px;
    line-height: 16px;
    font-weight: 400;
  }
  .sms-messages {
    scrollbar-width: none;
  }
  .sms-messages::-webkit-scrollbar {
    width: 0;
    height: 0;
  }
  .bubble {
    position: relative;
    max-width: 76%;
    padding: 8px 12px;
    border-radius: 18px;
    box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1);
  }
  .bubble-text {
    font-size: 15px;
    line-height: 20px;
    letter-spacing: -0.2px;
  }
  .bubble-incoming {
    color: #000000;
    background: #dcdcde;
  }
  .bubble-outgoing {
    color: #ffffff;
    background: #007aff;
  }
  .bubble-incoming .bubble-text {
    color: #000000 !important;
  }
  .bubble-outgoing .bubble-text {
    color: #ffffff !important;
  }
  .image-bubble {
    max-width: 76%;
    border-radius: 18px;
    overflow: hidden;
    position: relative;
  }
  .image-bubble-img {
    display: block;
    width: 100%;
    height: auto;
  }
  .sms-receipt {
    display: none;
    font-size: 11px;
    color: #8e8e93;
    margin-top: 2px;
    text-align: right;
    padding-right: 8px;
    font-weight: 400;
  }
  .sms-receipt.visible {
    display: block;
  }
</style>

<script>
  // Initialize immediately if DOM is ready; otherwise, wait for DOMContentLoaded.
  const initSMSMockups = () => {
    // Update time display
    const timeDisplays = Array.from(document.querySelectorAll('.sms-time-display'))
    const now = new Date()
    const hours = now.getHours()
    const minutes = now.getMinutes().toString().padStart(2, '0')
    const timeString = `${hours}:${minutes}`
    timeDisplays.forEach((display) => {
      display.textContent = timeString
    })

    // Randomize unread counts
    const unreadCounts = Array.from(document.querySelectorAll('.sms-unread-count'))
    unreadCounts.forEach((count) => {
      count.textContent = (Math.floor(Math.random() * 201) + 100).toString()
    })

    // Autoplay animation
    const mockups = Array.from(document.querySelectorAll('.sms-mockup'))
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches
    const MESSAGE_DELAY_MS = 1200

    const startedMockups = new WeakSet()

    const revealAll = (mockup: HTMLElement) => {
      const bubbles = Array.from(mockup.querySelectorAll('.sms-bubble')) as HTMLElement[]
      const times = Array.from(mockup.querySelectorAll('.sms-time')) as HTMLElement[]
      const receipt = mockup.querySelector('.sms-receipt') as HTMLElement | null
      const container = mockup.querySelector('.sms-messages') as HTMLElement | null

      bubbles.forEach((b) => b.classList.add('visible'))
      times.forEach((t) => t.classList.add('visible'))
      if (receipt) receipt.classList.add('visible')
      if (container) container.scrollTop = container.scrollHeight
    }

    // Core animation logic (used by both initial play and replay)
    const playAnimation = (mockup: HTMLElement) => {
      const bubbles = Array.from(mockup.querySelectorAll('.sms-bubble')) as HTMLElement[]
      const times = Array.from(mockup.querySelectorAll('.sms-time')) as HTMLElement[]
      const container = mockup.querySelector('.sms-messages') as HTMLElement | null
      const lastOutgoingAttr = mockup.getAttribute('data-last-outgoing')
      const lastOutgoing = lastOutgoingAttr ? parseInt(lastOutgoingAttr) : -1
      const receipt = mockup.querySelector('.sms-receipt') as HTMLElement | null

      if (prefersReducedMotion) {
        revealAll(mockup)
        return
      }

      let currentIndex = 0

      const revealNext = () => {
        if (currentIndex >= bubbles.length) return

        // Show timestamp if present for this message
        const time = times[currentIndex]
        if (time) time.classList.add('visible')

        // Show the message bubble
        bubbles[currentIndex].classList.add('visible')

        // Show receipt after last outgoing message
        if (receipt && currentIndex === lastOutgoing) {
          receipt.classList.add('visible')
        }

        // Scroll container to keep message visible
        if (container) {
          const idx = currentIndex // Capture before increment
          // Small delay to let images render
          setTimeout(() => {
            const target = bubbles[idx]
            if (!target) return
            const inputBarHeight = 80
            const targetBottom = target.offsetTop + target.offsetHeight
            const visibleHeight = container.clientHeight - inputBarHeight
            const scrollTarget = targetBottom - visibleHeight
            if (scrollTarget > container.scrollTop) {
              container.scrollTop = scrollTarget
            }
          }, 100)
        }

        currentIndex++

        if (currentIndex < bubbles.length) {
          setTimeout(revealNext, MESSAGE_DELAY_MS)
        }
      }

      // Start with first message visible immediately
      revealNext()
    }

    // Guarded wrapper for initial autoplay (prevents duplicate plays)
    const startAutoplay = (mockup: HTMLElement) => {
      // Cross-script guard: avoid multiple initializations across duplicate inline scripts
      if (mockup.dataset && mockup.dataset.started === 'true') {
        return
      }
      if (startedMockups.has(mockup)) {
        return
      }
      startedMockups.add(mockup)
      try {
        mockup.dataset.started = 'true'
      } catch {}

      playAnimation(mockup)
    }

    // Use IntersectionObserver to start autoplay when mockup is in view
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            startAutoplay(entry.target as HTMLElement)
            observer.unobserve(entry.target)
          }
        })
      },
      { threshold: 0.5 } // Start when 50% visible
    )

    mockups.forEach((m) => {
      const mockup = m as HTMLElement
      // If autoplay class is present, start immediately without IntersectionObserver
      if (mockup.classList.contains('sms-autoplay')) {
        startAutoplay(mockup)
      } else {
        observer.observe(mockup)
      }
    })

    // Add replay functionality
    const replayHints = Array.from(document.querySelectorAll('.sms-replay-hint'))
    replayHints.forEach((hint) => {
      const handleReplay = () => {
        const mockup = hint.closest('.sms-mockup') as HTMLElement | null
        if (!mockup) return

        // Reset all bubbles and times to hidden
        const bubbles = Array.from(mockup.querySelectorAll('.sms-bubble')) as HTMLElement[]
        const times = Array.from(mockup.querySelectorAll('.sms-time')) as HTMLElement[]
        const receipt = mockup.querySelector('.sms-receipt') as HTMLElement | null
        const container = mockup.querySelector('.sms-messages') as HTMLElement | null

        bubbles.forEach((b) => b.classList.remove('visible'))
        times.forEach((t) => t.classList.remove('visible'))
        if (receipt) receipt.classList.remove('visible')
        if (container) container.scrollTop = 0

        // Restart the animation (use playAnimation directly to bypass guards)
        setTimeout(() => playAnimation(mockup), 100)
      }

      hint.addEventListener('click', handleReplay)
      hint.addEventListener('keydown', (e) => {
        const keyEvent = e as KeyboardEvent
        if (keyEvent.key === 'Enter' || keyEvent.key === ' ') {
          keyEvent.preventDefault()
          handleReplay()
        }
      })
    })
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSMSMockups)
  } else {
    // DOM has already loaded; run immediately.
    initSMSMockups()
  }
</script>
